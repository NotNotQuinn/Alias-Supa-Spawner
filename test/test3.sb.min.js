/*! Created using 'Alias Supa Spawner' (https://github.com/NotNotQuinn/Alias-Supa-Spawner), Powered by UglifyJS */
/* Alias by QuinnDT, source: https://github.com/NotNotQuinn/Alias-Supa-Spawner/blob/main/test/test3.sb.js */
const ASS_Entry=function(){const applyParameters=(templatedArguments,inputArguments)=>{const resultArguments=[];const numberRegex=/(?<order>-?\d+)(\.\.(?<range>-?\d+))?(?<rest>\+?)/;for(let i=0;i<templatedArguments.length;i++){const parsed=templatedArguments[i].replace(/#{(.+?)}/g,(total,match)=>{const numberMatch=match.match(numberRegex);if(numberMatch){let order=Number(numberMatch.groups.order);if(order<0){order=inputArguments.length+order}let range=numberMatch.groups.range?Number(numberMatch.groups.range):null;if(typeof range==='number'){if(range<0){range=inputArguments.length+range+1}if(range<order){const temp=range;range=order;order=temp}}const useRest=numberMatch.groups.rest==='+';if(useRest&&range){return{success:false,reply:`Cannot combine both the \u{22}range\u{22} and \u{22}rest\u{22} argument identifiers!`}}else if(useRest){return inputArguments.slice(order).join(' ')}else if(range){return inputArguments.slice(order,range).join(' ')}else{return inputArguments[order]??''}}else if(match==='executor'){return executor}else if(match==='channel'){return channel}else{return total}});resultArguments.push(...parsed.split(' '))}return{success:true,resultArguments:resultArguments}};const error=msg=>`abb ac 0 a em:\u{22}${msg.replace('\u{22}','\'')}\u{22}`;const success=msg=>`abb say ${msg}`;function getExpression(args){const paramNames=['expression'];let params={};let argsString=args.join(' ');const quotesRegex=new RegExp(`(?<name>${paramNames.join('|')}):(?<!\\\\)\u{22}(?<value>.*?)(?<!\\\\)\u{22}`,'g');const quoteMatches=[...argsString.matchAll(quotesRegex)];for(const match of quoteMatches.reverse()){argsString=argsString.slice(0,match.index)+argsString.slice(match.index+match[0].length+1);const{name:name=null,value:value=null}=match.groups;const type='string';if(name!==null&&value!==null){const cleanValue=value.replace(/^\u{22}|\u{22}$/g,'').replace(/\\\u{22}/g,'\u{22}');const parsedValue=String(cleanValue);if(parsedValue===null){return{success:false,reply:`Cannot parse parameter \u{22}${name}\u{22}!`}}if(type==='object'){if(typeof params[name]==='undefined'){params[name]={}}if(typeof params[name][parsedValue.key]!=='undefined'){return{success:false,reply:`Cannot use multiple values for parameter \u{22}${name}\u{22}, key ${parsedValue.key}!`}}params[name][parsedValue.key]=parsedValue.value}else{params[name]=parsedValue}}const remainingArgs=argsString.split(' ');const paramRegex=new RegExp(`^(?<name>${paramNames.join('|')}):(?<value>.*)$`);for(let i=remainingArgs.length-1;i>=0;i--){if(!paramRegex.test(remainingArgs[i])){continue}const{name:name=null,value:value=null}=remainingArgs[i].match(paramRegex).groups;const{type}=command.Params.find(i=>i.name===name);if(name!==null&&value!==null){const parsedValue=Command.parseParameter(value,type);if(parsedValue===null){return{success:false,reply:`Cannot parse parameter \u{22}${name}\u{22}!`}}if(type==='object'){if(typeof params[name]==='undefined'){params[name]={}}if(typeof params[name][parsedValue.key]!=='undefined'){return{success:false,reply:`Cannot use multiple values for parameter \u{22}${name}\u{22}, key ${parsedValue.key}!`}}params[name][parsedValue.key]=parsedValue.value}else{params[name]=parsedValue}remainingArgs.splice(i,1)}}args=remainingArgs.filter(Boolean)}return{expression:params['expression'],newArgs:args}}console.log('old args',args);const{expression,newArgs}=getExpression(args);console.log({expression:expression,newArgs:newArgs});if(expression==null)return success(newArgs.join(' '));let res=applyParameters(expression.split(' '),newArgs);console.log({res:res});if(res.success)return success(res.resultArguments.join(' '));else return error(res.reply)};ASS_Entry();